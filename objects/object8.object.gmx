<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>500</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// ############ MOJO HACK ############ //
//instance_create(x,y,O_Ini); 
image_speed=0.05;
timer_restart = 0;
// ############ MOJO HACK ############ //



texture_set_blending(false); //we wont be needing this for our shitey game
texture_set_interpolation(false);

groundx = 0;
groundy = room_height-background_get_height(background1)*SCALE;
//views
view_enabled = 1;
view_wview[0] = room_width;
view_hview[0] = room_height;
if (os_type == os_windows || os_type == os_macosx || os_type == os_linux) //multiplatform goodnesses
{
    scr_h = display_get_height()-50; scr_w = floor(scr_h*720/1280);
    view_wport[0] = scr_w;
    view_hport[0] = scr_h;
    window_set_size(scr_w,scr_h);
    window_set_position(0,0);
}
view_visible[0] = 1;
dc=c_white;
//Make stuffs happen
global.pipes = 0; //Score
global.d = .5; //potentially can be used for delta timing
global.worldSpeed = 2*SCALE;

instance_create(room_width/5,room_height/2.5,objPlayer); //only going to be one player object at a time, no need to record the id

dist = 1.70; //distribution of pipes (ie approximately how many will be on screen at once)

tileNo = ceil(room_width/background_get_width(background1))+ceil(global.worldSpeed/background_get_width(background1));
playArea = room_height-background_get_height(background1);

display_set_gui_size(room_width,room_height);

tut=1;

timer[0]=-1;

menuY = room_height;
fade = 0.001;

//The SCALE constant is for when I was mucking around with different resolutions but it still should work, i think
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// ############ MOJO HACK ############ //
Sr_Insert_Coin();
Sr_Game_Exit();
// reset kesy to default values
if keyboard_check_pressed(ord("0")) {
    file_delete("settings.ini");
    room_restart();
}

// ############ MOJO HACK ############ //


///Update movements
groundx-=global.worldSpeed*global.d;
groundx = groundx mod ((24+24*ceil(global.worldSpeed/24))*SCALE); //every 7 pixels jump the floor back to the start, creates the illusion it is moving

///Timer
if timer[0]&lt;&gt;-1
timer[0] = max(0,timer[0]-global.d);
if timer[0] == 0{
    if (global.worldSpeed&lt;=0) timer[0]=-1;
    else
    {
        tempheight = ((playArea/5)+random(playArea/5));
        tempside = choose(1,0);
        
        with (instance_create(room_width+SCALE*(sprite_get_width(sprPipeTop)/2),0,objPipe)){
            height = other.tempheight;
            side = !other.tempside;
        }
        with (instance_create(room_width+SCALE*(sprite_get_width(sprPipeTop)/2),0,objPipe)){
            height = other.groundy-other.tempheight-other.playArea*.23;
            side = other.tempside;
        }
        
        timer[0] = (room_width/dist)/(global.worldSpeed);
    }
}

if tut {
    //if mouse_check_button_pressed(mb_left) tut=0;}
    if keyboard_check_pressed(vk_anykey) {
            if global.Price = 0 || global.Credits &gt; 0 {
            tut=0;
            }
         }
}
    
else if (timer[0]==-1 and global.worldSpeed&gt;0){
timer[0] = (room_width/dist)/(global.worldSpeed);
}

//Menu stuff
if (global.worldSpeed == 0){
    if dc&lt;&gt;c_lime
    if (global.pipes &gt; global.best) {dc = c_lime; global.best=global.pipes
    /*
    file_delete("settings.ini");
    ini_open("settings.ini")
    ini_write_real("options","score",global.pipes);
    ini_close()
    */
    } else dc = c_white;
    menuY/=2
    if menuY&lt;2 menuY=0
    //if (mouse_check_button_pressed(mb_left)){
    
    /*####### MOJO ####### */
    timer_restart+=1;
    if timer_restart &gt; 500 room_restart();
    
    if keyboard_check_pressed(vk_anykey) {
        
            audio_play_sound(sfx_whoosh,0,0);
            fade = 1;
        
        /* 
        if (point_distance(mouse_x,mouse_y,room_width/2,menuY+(room_height/4)*3)&lt;=25){ //how to be lazy by zbox
            audio_play_sound(sfx_whoosh,0,0);
            fade = 1;
        }
        */
    }
if fade &gt; 0{
    fade-=global.d*.08;
    if fade&lt;=0 fade = -1;
}
if fade==-1{
    room_restart();
}
} else {
    if fade&gt;=0.001{
        fade+=.15*global.d;
        if fade&gt;1 fade=0
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// ############ MOJO HACK ############ //
if global.Price &gt; 0 {
draw_set_font(F_Pixel);
draw_set_halign(fa_left);
draw_set_color(c_white);
draw_text_transformed(5,5,"CREDITS: " + string(global.Credits),0.5,0.5,0);
}
// ############ MOJO HACK ############ //


draw_set_font(font0);
draw_set_halign(fa_center);
draw_set_valign(fa_middle);
texture_set_blending(1);
draw_set_color(c_black);
draw_text(room_width/2+1,(room_height/5+1)-(room_height-menuY)/4,string(global.pipes));
draw_set_color(c_white);
draw_text(room_width/2,(room_height/5)-(room_height-menuY)/4,string(global.pipes));
if (global.worldSpeed==0){
    draw_set_halign(fa_center);
    draw_set_font(font1);
    draw_set_color(c_black);
        draw_text(room_width/4+1,room_height/2+menuY-20+1,"Score");
        draw_text((room_width/4)*3+1,room_height/2+menuY-20+1,"Best");
    draw_set_color(c_white);
        draw_text(room_width/4,room_height/2+menuY-20,"Score");
        draw_text((room_width/4)*3,room_height/2+menuY-20,"Best");
    draw_set_font(font0);  
    draw_set_color(c_black);  
        draw_text(room_width/4+2,menuY+room_height/2+2,string(global.pipes));
        draw_text((room_width/4*3+2),menuY+room_height/2+2,string(global.best));
    draw_set_color(c_white);
        draw_text(room_width/4,menuY+room_height/2,string(global.pipes));
    draw_set_color(dc);
        draw_text((room_width/4*3),menuY+room_height/2,string(global.best));
    //draw_sprite(sprPlay,0,room_width/2,menuY+(room_height/4)*3);
    //draw_text(room_width/4,menuY+room_height/2,string(global.pipes));
    //draw_text_transformed(room_width/4,menuY+room_height/2,"PRESS BUTTON TO RESTART",0.3,0.3,0);

      draw_set_font(F_Pixel);
      draw_set_color(c_white); 
        draw_text_transformed(room_width/4+0.5+36,menuY+room_height/12+30+1,"PRESS  BUTTON",0.7,0.7,0);
        draw_text_transformed(room_width/4+0.5+36,menuY+room_height/12+30+1+10,"TO  RESTART",0.7,0.7,0);    
      

 
  
} else if tut
    draw_sprite_ext(spr_instructions,-1,room_width/2,room_height/2,.6,.6,0,$ffffff,1);

if fade&gt;0{
draw_set_alpha(1-fade);
draw_set_color(c_black);
draw_rectangle(0,0,room_width,room_height,0);
draw_set_alpha(1);}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//draw ground

texture_set_interpolation(false);
for (var i=0; i&lt;=tileNo; ++i)
    draw_background_ext(background1,groundx+i*background_get_width(background1),groundy,SCALE,SCALE,0,c_white,1);
    

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
